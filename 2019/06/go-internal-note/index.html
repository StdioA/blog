<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="referrer" content="no-referrer-when-downgrade"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no,minimal-ui"><meta name="renderer" content="webkit"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=no,email=no,adress=no"><meta name="theme-color" content="#2a3f5b"><meta http-equiv="window-target" content="_top"><title>《深入解析Go》笔记 | Stdio&#39;s Blog</title><meta name="description" content="在 GitHub 上找到一本解读 Go 实现细节的好书，名叫《深入解析 Go》。大致看了一遍，简单做了些笔记。"><meta name="keywords" content="Golang"><meta property="og:type" content="article"><meta property="og:title" content="《深入解析Go》笔记"><meta property="og:url" content="https://blog.stdioa.com/2019/06/go-internal-note/index.html"><meta property="og:site_name" content="Stdio&#39;s Blog"><meta property="og:description" content="在 GitHub 上找到一本解读 Go 实现细节的好书，名叫《深入解析 Go》。大致看了一遍，简单做了些笔记。"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://i6448038.github.io/img/csp/GMPrelation.png"><meta property="og:updated_time" content="2019-06-24T08:40:49.945Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="《深入解析Go》笔记"><meta name="twitter:description" content="在 GitHub 上找到一本解读 Go 实现细节的好书，名叫《深入解析 Go》。大致看了一遍，简单做了些笔记。"><meta name="twitter:image" content="https://i6448038.github.io/img/csp/GMPrelation.png"><link rel="canonical" href="https://blog.stdioa.com/2019/06/go-internal-note/index.html"><link rel="alternate" href="/atom.xml" title="Stdio&#39;s Blog" type="application/atom+xml"><link rel="icon" href="/favicon.ico" type="image/x-icon"><link rel="stylesheet" href="/css/style.min.css"></head><body class="main-center theme-black" itemscope itemtype="http://schema.org/WebPage"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="slimContent"><div class="navbar-header"><div class="profile-block text-center"><a id="avatar" href="/" target="_blank"><img class="img-circle img-rotate" src="https://www.gravatar.com/avatar/e452ed622e6b1e9a2067a06fde30cf30?s=128" width="200" height="200"></a><h2 id="name" class="hidden-xs hidden-sm">David Dai</h2><h3 id="title" class="hidden-xs hidden-sm hidden-md">Backend Developer</h3><small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Nanjing, China</small></div><div class="search" id="search-form-wrap"><form class="search-form sidebar-form"><div class="input-group"><input type="text" class="search-form-input form-control" placeholder="搜索"> <span class="input-group-btn"><button type="submit" class="search-form-submit btn btn-flat" onclick="return!1"><i class="icon icon-search"></i></button></span></div></form><div class="ins-search"><div class="ins-search-mask"></div><div class="ins-search-container"><div class="ins-input-wrapper"><input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech> <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button></div><div class="ins-section-wrapper"><div class="ins-section-container"></div></div></div></div></div><button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false"><span class="sr-only">Toggle navigation</span> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span></button></div><nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation"><ul class="nav navbar-nav main-nav menu-highlight"><li class="menu-item menu-item-home"><a href="/"><i class="icon icon-home-fill"></i> <span class="menu-title">首页</span></a></li><li class="menu-item menu-item-archives"><a href="/archives"><i class="icon icon-archives-fill"></i> <span class="menu-title">归档</span></a></li><li class="menu-item menu-item-categories"><a href="/categories"><i class="icon icon-folder"></i> <span class="menu-title">分类</span></a></li><li class="menu-item menu-item-tags"><a href="/tags"><i class="icon icon-tags"></i> <span class="menu-title">标签</span></a></li><li class="menu-item menu-item-repository"><a href="/repository"><i class="icon icon-project"></i> <span class="menu-title">项目</span></a></li><li class="menu-item menu-item-sheets"><a href="http://sheet.stdioa.com/"><i class="icon icon-book"></i> <span class="menu-title">谱站</span></a></li><li class="menu-item menu-item-links"><a href="/links"><i class="icon icon-friendship"></i> <span class="menu-title">友链</span></a></li><li class="menu-item menu-item-about"><a href="/about"><i class="icon icon-cup-fill"></i> <span class="menu-title">关于</span></a></li></ul><ul class="social-links"><li><a href="https://github.com/StdioA" target="_blank" title="Github" data-toggle="tooltip" data-placement="top"><i class="icon icon-github"></i></a></li><li><a href="https://twitter.com/stdio_a" target="_blank" title="Twitter" data-toggle="tooltip" data-placement="top"><i class="icon icon-twitter"></i></a></li><li><a href="/atom.xml" target="_blank" title="Rss" data-toggle="tooltip" data-placement="top"><i class="icon icon-rss"></i></a></li><li><a href="https://t.me/StdioA" target="_blank" title="Telegram" data-toggle="tooltip" data-placement="top"><i class="icon icon-telegram"></i></a></li></ul></nav></div></header><aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar"><div class="slimContent"><div class="widget"><h3 class="widget-title">公告</h3><div class="widget-body"><div id="board"><div class="content"><p>欢迎，你是第 <span id="busuanzi_value_site_pv">并不知道多少</span> 个来到这里的人。</p><p>不过我更新的比较少…不好意思。</p><p>另：本站使用 Disqus 评论系统，若文章页面下方无法显示评论框，那肯定是打开方式不对。</p></div></div></div></div><div class="widget"><h3 class="widget-title">分类</h3><div class="widget-body"><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/DevOps/">DevOps</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Golang/">Golang</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Javascript/">Javascript</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/LeetCode/">LeetCode</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Web/">Web</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/乱七八糟/">乱七八糟</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/开发/">开发</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络/">网络</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/翻译/">翻译</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/随手记/">随手记</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/随笔/">随笔</a><span class="category-list-count">2</span></li></ul></div></div><div class="widget"><h3 class="widget-title">标签云</h3><div class="widget-body tagcloud"><a href="/tags/Ajax/" style="font-size:13px">Ajax</a> <a href="/tags/Apache/" style="font-size:13px">Apache</a> <a href="/tags/Atom/" style="font-size:13px">Atom</a> <a href="/tags/Beancount/" style="font-size:13px">Beancount</a> <a href="/tags/CI-CD/" style="font-size:13.5px">CI/CD</a> <a href="/tags/CTF/" style="font-size:13.17px">CTF</a> <a href="/tags/DevOps/" style="font-size:13.67px">DevOps</a> <a href="/tags/Django/" style="font-size:13.33px">Django</a> <a href="/tags/Django-REST-Framework/" style="font-size:13px">Django REST Framework</a> <a href="/tags/Docker/" style="font-size:13px">Docker</a> <a href="/tags/Git/" style="font-size:13.17px">Git</a> <a href="/tags/GitLab/" style="font-size:13.5px">GitLab</a> <a href="/tags/Github/" style="font-size:13.17px">Github</a> <a href="/tags/Golang/" style="font-size:13.33px">Golang</a> <a href="/tags/IPv6/" style="font-size:13px">IPv6</a> <a href="/tags/Javascript/" style="font-size:13.17px">Javascript</a> <a href="/tags/KMS/" style="font-size:13px">KMS</a> <a href="/tags/LCTT/" style="font-size:13px">LCTT</a> <a href="/tags/LeetCode/" style="font-size:13px">LeetCode</a> <a href="/tags/Let-s-Encrypt/" style="font-size:13px">Let's Encrypt</a> <a href="/tags/Linux/" style="font-size:13.33px">Linux</a> <a href="/tags/MySQL/" style="font-size:13.17px">MySQL</a> <a href="/tags/NAS/" style="font-size:13px">NAS</a> <a href="/tags/NTP/" style="font-size:13px">NTP</a> <a href="/tags/PHP/" style="font-size:13px">PHP</a> <a href="/tags/Prometheus/" style="font-size:13px">Prometheus</a> <a href="/tags/Protobuf/" style="font-size:13px">Protobuf</a> <a href="/tags/Python/" style="font-size:13.83px">Python</a> <a href="/tags/SQL/" style="font-size:13px">SQL</a> <a href="/tags/Sublime-Text/" style="font-size:13px">Sublime Text</a> <a href="/tags/Windows/" style="font-size:13px">Windows</a> <a href="/tags/collections/" style="font-size:13px">collections</a> <a href="/tags/ctypes/" style="font-size:13px">ctypes</a> <a href="/tags/fava/" style="font-size:13px">fava</a> <a href="/tags/git/" style="font-size:13px">git</a> <a href="/tags/gunicorn/" style="font-size:13px">gunicorn</a> <a href="/tags/logging/" style="font-size:13px">logging</a> <a href="/tags/nginx/" style="font-size:13.33px">nginx</a> <a href="/tags/node-js/" style="font-size:13.17px">node.js</a> <a href="/tags/openssl/" style="font-size:13px">openssl</a> <a href="/tags/pip/" style="font-size:13px">pip</a> <a href="/tags/python/" style="font-size:14px">python</a> <a href="/tags/requests/" style="font-size:13px">requests</a> <a href="/tags/supervisor/" style="font-size:13px">supervisor</a> <a href="/tags/unittest/" style="font-size:13px">unittest</a> <a href="/tags/virtualenv/" style="font-size:13px">virtualenv</a> <a href="/tags/vue-js/" style="font-size:13px">vue.js</a> <a href="/tags/wget/" style="font-size:13px">wget</a> <a href="/tags/七牛/" style="font-size:13px">七牛</a> <a href="/tags/上下文管理/" style="font-size:13px">上下文管理</a> <a href="/tags/前端开发/" style="font-size:13.33px">前端开发</a> <a href="/tags/后端开发/" style="font-size:13px">后端开发</a> <a href="/tags/堆/" style="font-size:13px">堆</a> <a href="/tags/微服务/" style="font-size:13.17px">微服务</a> <a href="/tags/数据库/" style="font-size:13px">数据库</a> <a href="/tags/数据迁移/" style="font-size:13px">数据迁移</a> <a href="/tags/文本编辑器/" style="font-size:13px">文本编辑器</a> <a href="/tags/算法/" style="font-size:13px">算法</a> <a href="/tags/编程工具/" style="font-size:13px">编程工具</a> <a href="/tags/脑洞/" style="font-size:13.17px">脑洞</a> <a href="/tags/记账/" style="font-size:13px">记账</a> <a href="/tags/读书/" style="font-size:13.5px">读书</a> <a href="/tags/迭代器/" style="font-size:13px">迭代器</a></div></div><div class="widget"><h3 class="widget-title">归档</h3><div class="widget-body"><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">十二月 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">九月 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">六月 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">十二月 2018</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">十月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">七月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">六月 2018</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">十二月 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">十一月 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">五月 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">四月 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">三月 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">二月 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">一月 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">十二月 2015</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/11/">十一月 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">十月 2015</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">九月 2015</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/07/">七月 2015</a><span class="archive-list-count">1</span></li></ul></div></div></div></aside><aside class="sidebar sidebar-toc collapse" id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar"><div class="slimContent"><nav id="toc" class="article-toc"><h3 class="toc-title">文章目录</h3><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#数据结构"><span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#string-底层结构"><span class="toc-text">string 底层结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#slice-底层结构"><span class="toc-text">slice 底层结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#map-底层结构"><span class="toc-text">map 底层结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#channel"><span class="toc-text">channel</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#interface"><span class="toc-text">interface</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法调用"><span class="toc-text">方法调用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数调用协议"><span class="toc-text">函数调用协议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#连续栈"><span class="toc-text">连续栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#闭包"><span class="toc-text">闭包</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#go-程序初始化"><span class="toc-text">Go 程序初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#调度模型"><span class="toc-text">调度模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#go-如何实现并发"><span class="toc-text">Go 如何实现并发？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#系统调用细节"><span class="toc-text">系统调用细节</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内存管理"><span class="toc-text">内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#内存池"><span class="toc-text">内存池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#垃圾回收"><span class="toc-text">垃圾回收</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#网络"><span class="toc-text">网络</span></a></li></ol></nav></div></aside><main class="main" role="main"><div class="content"><article id="post-go-internal-note" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting"><div class="article-header"><h1 class="article-title" itemprop="name">《深入解析Go》笔记</h1><div class="article-meta"><span class="article-date"><i class="icon icon-calendar-check"></i> <a href="/2019/06/go-internal-note/" class="article-date"><time datetime="2019-06-24T08:22:00.000Z" itemprop="datePublished">2019-06-24</time></a></span> <span class="article-category"><i class="icon icon-folder"></i> <a class="article-category-link" href="/categories/Golang/">Golang</a></span> <span class="article-tag"><i class="icon icon-tags"></i> <a class="article-tag-link" href="/tags/Golang/">Golang</a></span> <span class="article-read hidden-xs"><i class="icon icon-eye-fill" aria-hidden="true"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></span> <span class="post-comment"><i class="icon icon-comment"></i> <a href="/2019/06/go-internal-note/#comments" class="article-comment-link">评论</a></span> <span class="post-wordcount hidden-xs" itemprop="wordCount">字数统计: 3,510(字)</span></div></div><div class="article-entry marked-body" itemprop="articleBody"><p>在 GitHub 上找到一本解读 Go 实现细节的好书，名叫<a href="https://github.com/tiancaiamao/go-internals/" target="_blank" rel="noopener">《深入解析 Go》</a>。<br>大致看了一遍，简单做了些笔记。</p><a id="more"></a><p>这本书的代码来自 Go 1.3，所以还有一部分由 C 语言写成。<br>这份笔记里的代码来自 Go 1.12.5，数据结构全部由 Go 语言实现。</p><h2 id="数据结构"><a class="markdownIt-Anchor" href="#数据结构"></a> 数据结构</h2><p>string 和 slice 都是引用类型，可能开在栈上，也可能开在堆上；<br>channel 和 map 是引用类型，但一定开在堆上，栈中只有指针。</p><h3 id="string-底层结构"><a class="markdownIt-Anchor" href="#string-底层结构"></a> string 底层结构</h3><p><code>src/reflect/value.go</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StringHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">    Data <span class="keyword">uintptr</span></span><br><span class="line">    Len  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>string 是不可变数据结构，任何对 string 的操作都会产生一个新的 string. 因此，需要拼接的时候尽量使用 <code>bytes.Buffer</code>，或 <code>strings.Join</code> 这种用了 Buffer 的函数。</p><h3 id="slice-底层结构"><a class="markdownIt-Anchor" href="#slice-底层结构"></a> slice 底层结构</h3><p><code>src/reflect/value.go</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SliceHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">    Data <span class="keyword">uintptr</span></span><br><span class="line">    Len  <span class="keyword">int</span></span><br><span class="line">    Cap  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，两个数据结构的底层数据全部共享。<br>关于 slice 的扩容，可以参见<a href="https://halfrost.com/go_slice/" target="_blank" rel="noopener">《深入解析 Go 中 Slice 底层实现》</a>。<br>有一个小用法：对切片做 slice 操作时，末位的下标可以超过原 slice 的 len，但不能超过 cap.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">2</span>, <span class="number">10</span>)</span><br><span class="line">b := a[:<span class="number">5</span>]</span><br></pre></td></tr></table></figure><h3 id="map-底层结构"><a class="markdownIt-Anchor" href="#map-底层结构"></a> map 底层结构</h3><p><code>src/runtime/map.go</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// Note: the format of the hmap is also encoded in cmd/compile/internal/gc/reflect.go.</span></span><br><span class="line">    <span class="comment">// Make sure this stays in sync with the compiler's definition.</span></span><br><span class="line">    count     <span class="keyword">int</span> <span class="comment">// # live cells == size of map.  Must be first (used by len() builtin)</span></span><br><span class="line">    flags     <span class="keyword">uint8</span></span><br><span class="line">    B         <span class="keyword">uint8</span>  <span class="comment">// log_2 of # of buckets (can hold up to loadFactor * 2^B items)</span></span><br><span class="line">    noverflow <span class="keyword">uint16</span> <span class="comment">// approximate number of overflow buckets; see incrnoverflow for details</span></span><br><span class="line">    hash0     <span class="keyword">uint32</span> <span class="comment">// hash seed</span></span><br><span class="line"></span><br><span class="line">    buckets    unsafe.Pointer <span class="comment">// array of 2^B Buckets. may be nil if count==0.</span></span><br><span class="line">    oldbuckets unsafe.Pointer <span class="comment">// previous bucket array of half the size, non-nil only when growing</span></span><br><span class="line">    nevacuate  <span class="keyword">uintptr</span>        <span class="comment">// progress counter for evacuation (buckets less than this have been evacuated)</span></span><br><span class="line"></span><br><span class="line">    extra *mapextra <span class="comment">// optional fields</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// tophash generally contains the top byte of the hash value</span></span><br><span class="line">    <span class="comment">// for each key in this bucket. If tophash[0] &lt; minTopHash,</span></span><br><span class="line">    <span class="comment">// tophash[0] is a bucket evacuation state instead.</span></span><br><span class="line">    <span class="comment">// 用于 hash 的快速比较，当 hash 相等的时候还会跟原 key 进行一次匹配。</span></span><br><span class="line">    tophash [bucketCnt]<span class="keyword">uint8</span></span><br><span class="line">    <span class="comment">// Followed by bucketCnt keys and then bucketCnt values.</span></span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> packing all the keys together and then all the values together makes the</span></span><br><span class="line">    <span class="comment">// code a bit more complicated than alternating key/value/key/value/... but it allows</span></span><br><span class="line">    <span class="comment">// us to eliminate padding which would be needed for, e.g., map[int64]int8.</span></span><br><span class="line">    <span class="comment">// Followed by an overflow pointer.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意看上面的 NOTE 里的 KV 排列结构，这样做有利于内存对齐。<br><code>bmap</code> 后面的内存分配未在结构体中定义，需要拿 KV 的时候要通过 <code>unsafe.Pointer</code> 根据 offset 去拿。<br>见 <code>mapaccess1</code> 或 <code>mapaccess2</code>.</p><p>哈希表在每次扩容时，容量会增大到原来的两倍，也就是从 <code>2^B</code> 到 <code>2^(B+1)</code>。为了保证运行效率，会将 key 的搬迁操作平摊到每一次写操作（insert &amp; remove）上，每次操作时迁移 1-2 个键值对。查找时会先在 <code>old—buckets</code> 中找，找不到再去新的 <code>buckets</code> 中找。</p><p>map 使用快速的 murmurhash 作为哈希算法。</p><p><code>map</code> 解决冲突的方法是链地址法的改进形式。<br>在创建 <code>bmap</code> 时，会分配一个数组，都可以容纳 8 个键值对。发生哈希冲突时，都会将新的键值对放入添加到数组里。如果数组放满了，则会新建一个 <code>bmap</code>，通过 <code>overflow</code> 指针来链接到当前 bucket 节点后面。</p><p>关于查找、插入和删除的细节，请见<a href="https://tiancaiamao.gitbooks.io/go-internals/content/zh/02.3.html" target="_blank" rel="noopener">该书相关章节</a>。<br>一个需要注意的点：在 bmap 链中，相同的 Key 可能会存在于两个 bucket 里，而前面 bucket 的值会直接覆盖后面 bucket 的值。在进行更新操作时，如果前面 bucket 不存在该键，但是数组包含空位，则直接在该 bucket 中插入，而不会再去链表后面的 bucket 中查找并更新。查找操作亦然。<em>怎么说，这个机制有点像 docker 镜像中的不同层的文件覆盖机制。</em></p><h3 id="channel"><a class="markdownIt-Anchor" href="#channel"></a> channel</h3><p><code>src/runtime/chan.go</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">    qcount   <span class="keyword">uint</span>           <span class="comment">// 环形队列的总数量</span></span><br><span class="line">    dataqsiz <span class="keyword">uint</span>           <span class="comment">// 环形队列大小</span></span><br><span class="line">    buf      unsafe.Pointer <span class="comment">// 环形队列</span></span><br><span class="line">    elemsize <span class="keyword">uint16</span></span><br><span class="line">    closed   <span class="keyword">uint32</span></span><br><span class="line">    elemtype *_type <span class="comment">// 元素类型</span></span><br><span class="line">    sendx    <span class="keyword">uint</span>   <span class="comment">// 缓存区的发送指针（也就是缓冲区尾）</span></span><br><span class="line">    recvx    <span class="keyword">uint</span>   <span class="comment">// 缓冲区的接收索引（也就是缓冲区头）</span></span><br><span class="line">    recvq    waitq  <span class="comment">// 因接收而阻塞的等待队列</span></span><br><span class="line">    sendq    waitq  <span class="comment">// 因发送而阻塞的等待队列</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// lock protects all fields in hchan, as well as several</span></span><br><span class="line">    <span class="comment">// fields in sudogs blocked on this channel.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Do not change another G's status while holding this lock</span></span><br><span class="line">    <span class="comment">// (in particular, do not ready a G), as this can deadlock</span></span><br><span class="line">    <span class="comment">// with stack shrinking.</span></span><br><span class="line">    lock mutex</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> waitq <span class="keyword">struct</span> &#123;</span><br><span class="line">    first *sudog</span><br><span class="line">    last  *sudog</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> sudog <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// The following fields are protected by the hchan.lock of the</span></span><br><span class="line">    <span class="comment">// channel this sudog is blocking on. shrinkstack depends on</span></span><br><span class="line">    <span class="comment">// this for sudogs involved in channel ops.</span></span><br><span class="line"></span><br><span class="line">    g *g</span><br><span class="line"></span><br><span class="line">    <span class="comment">// isSelect indicates g is participating in a select, so</span></span><br><span class="line">    <span class="comment">// g.selectDone must be CAS'd to win the wake-up race.</span></span><br><span class="line">    isSelect <span class="keyword">bool</span></span><br><span class="line">    next     *sudog</span><br><span class="line">    prev     *sudog</span><br><span class="line">    elem     unsafe.Pointer <span class="comment">// data element (may point to stack)</span></span><br><span class="line">                            <span class="comment">// 存储 goroutine 的</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// The following fields are never accessed concurrently.</span></span><br><span class="line">    <span class="comment">// For channels, waitlink is only accessed by g.</span></span><br><span class="line">    <span class="comment">// For semaphores, all fields (including the ones above)</span></span><br><span class="line">    <span class="comment">// are only accessed when holding a semaRoot lock.</span></span><br><span class="line"></span><br><span class="line">    acquiretime <span class="keyword">int64</span></span><br><span class="line">    releasetime <span class="keyword">int64</span></span><br><span class="line">    ticket      <span class="keyword">uint32</span></span><br><span class="line">    parent      *sudog <span class="comment">// semaRoot binary tree</span></span><br><span class="line">    waitlink    *sudog <span class="comment">// g.waiting list or semaRoot</span></span><br><span class="line">    waittail    *sudog <span class="comment">// semaRoot</span></span><br><span class="line">    c           *hchan <span class="comment">// channel</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以前 channel 的缓冲区会在 hchan 之后的内存中创建，现在将它们分开了。<br>对 channel 进行读写操作的时候，会根据缓冲区的状态、以及读 / 写链表来决定是否要阻塞当前 goroutine，阻塞的话会将当前的 G 挂载链表中。</p><h3 id="interface"><a class="markdownIt-Anchor" href="#interface"></a> interface</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 带方法的接口</span></span><br><span class="line"><span class="keyword">type</span> iface <span class="keyword">struct</span> &#123;</span><br><span class="line">    tab  *itab</span><br><span class="line">    data unsafe.Pointer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> itab <span class="keyword">struct</span> &#123;</span><br><span class="line">    inter *interfacetype</span><br><span class="line">    _type *_type</span><br><span class="line">    hash  <span class="keyword">uint32</span> <span class="comment">// copy of _type.hash. Used for type switches.</span></span><br><span class="line">    _     [<span class="number">4</span>]<span class="keyword">byte</span></span><br><span class="line">    fun   [<span class="number">1</span>]<span class="keyword">uintptr</span> <span class="comment">// variable sized. fun[0]==0 means _type does not implement inter.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// fun 中会保存接口值背后具体类型的方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 空接口</span></span><br><span class="line"><span class="keyword">type</span> eface <span class="keyword">struct</span> &#123;</span><br><span class="line">    _type *_type</span><br><span class="line">    data  unsafe.Pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Type</code> 的 <code>UncommonType</code> 会记录某个<strong>具体类型</strong>实现的方法；<br><code>interface</code> 的 <code>Itab</code> 的 <code>InterfaceType</code> 中的方法表，记录了接口所声明的方法；<br><code>itab</code> 的 <code>fun</code> 数组，记录了具体的函数指针，用作接口值的方法缓存。</p><p>在接口值赋值时，会将 <code>UncommonType</code> 和 <code>InterfaceType</code> 中的方法表进行比对；如果比对成功的话，会将 <code>UncommonType</code> 中的方法指针拷贝到 <code>itab</code> 的 <code>fun</code> 中，方便方法调用时对方法进行查找。</p><h3 id="方法调用"><a class="markdownIt-Anchor" href="#方法调用"></a> 方法调用</h3><p><code>a.F(b)</code> 会在编译时直接转换为 <code>A.F(a, b)</code>；<br>当一个类型被匿名嵌入结构体时，它的方法会被拷贝到嵌入结构体的 Type 的方法表中。这个过程在编译时就可以完成。</p><p>接口的方法调用要通过 <code>itab.fun</code> 中的函数指针来确定具体调用的方法。方法拷贝的过程是在运行时完成的，所以接口的方法调用的成本要略高于一般方法调用。</p><h2 id="函数调用协议"><a class="markdownIt-Anchor" href="#函数调用协议"></a> 函数调用协议</h2><p>Go 把返回值放在上一个栈帧最后的内存中，这样调用链前后的两个函数都可以触及到这段内存，以此来实现多值返回。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">返回值2</span><br><span class="line">返回值1</span><br><span class="line">参数3</span><br><span class="line">参数2</span><br><span class="line">参数1 &lt;- SP</span><br></pre></td></tr></table></figure><p>go 关键字是个语法糖，<code>go f(args)</code> 可以看做 <code>runtine.newproc(size, f, args)</code>；<br>同样 defer 也是语法糖，通过 <code>runtine.deferproc</code> 和 <code>runtine.deferreturn</code> 来实现。</p><h3 id="连续栈"><a class="markdownIt-Anchor" href="#连续栈"></a> 连续栈</h3><p>一个程序中可能会有非常多的 goroutine，为了节省内存，每个 goroutine 一开始只会得到非常小的一块栈。</p><p>使用可变栈时，每次函数调用时，都会通过 SP 和 stackguard 检查栈的使用情况。<br>当栈不够大时，会进行栈扩张，开一块新栈，并把旧栈的内容复制过去。如果栈里有指针，而指针指向的是栈中的变量，那么在复制时会对指针的值加一个偏移，来保证指针指向的对象是被迁移过后的对象。<br>gc 时，如果检测到栈只用了不到 1/4 时，会将栈缩小为原来的 1/2.</p><h3 id="闭包"><a class="markdownIt-Anchor" href="#闭包"></a> 闭包</h3><p>Go 通过 escape analyze 来检查逃逸的值，从而确定该值是否应该在堆上创建，而不是在栈中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span> *<span class="title">T</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> t T</span><br><span class="line">    <span class="keyword">return</span> &amp;t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回闭包时并不是单纯返回一个函数，而是返回了一个结构体，记录下函数返回地址和引用的环境中的变量地址。书中是有这样一个结构体的，但在我的源码里，这个数据结构应该是用汇编实现了。</p><h2 id="go-程序初始化"><a class="markdownIt-Anchor" href="#go-程序初始化"></a> Go 程序初始化</h2><ul><li>系统初始化：初始化栈、设置本地线程存储（g）</li><li>调度器初始化：<code>runtime.schedinit</code><br>根据 <code>GOMAXPROCS</code> 决定可用线程数；把 <code>runtime.main</code> 放入就绪线程队列；<br>调用 <code>runtime.mstart</code>，<code>mstart</code> 调用 <code>schedule</code>，也就是一直运行的调度器。</li><li><code>schedule</code> 选中 <code>runtime.main</code><ul><li>通过 <code>newm(sysmon, nil)</code> 启动一个线程运行 <code>sysmon</code>，用于处理网络 epoll</li><li>通过 <code>runtime.newproc</code> 启动一个 G 执行 scavenger，用于垃圾回收</li><li>调用 <code>main.main</code> 进入用户代码。</li></ul></li></ul><p>会单独启动一个线程（M）用于 <code>poll()</code>。GC 都是 goroutine，这个任务的地位是高于 GC 的。</p><h2 id="调度模型"><a class="markdownIt-Anchor" href="#调度模型"></a> 调度模型</h2><h3 id="go-如何实现并发"><a class="markdownIt-Anchor" href="#go-如何实现并发"></a> Go 如何实现并发？</h3><p>Go 通过 goroutine 和 channel 来实现 CSP 并发模型，从而实现并发。</p><ul><li>goroutine 是 Go 语言中并发的执行单位。可以理解为轻量级的“线程”。</li><li>channel 是 Go 语言中各个并发结构体 (goroutine) 之前的通信机制。 通俗的讲，就是各个 goroutine 之间通信的“管道”，有点类似于 Linux 中的管道。</li></ul><p>再深入一点，Go 线程模型的实现依靠 MPG 以及 Sched 结构体。<br>M 是 Machine，是对机器的抽象，一个 M 会关联一个物理线程；<br>P 是 Processor，代表 Go 代码执行是所需要的资源；<br>G 是 Goroutine，代表 Goroutine 的控制结构；<br>Sched 是调度实现中使用的数据结构。</p><p>多个 G 会以队列的形式挂靠在 P 上；当 G 与 M 绑定时，才能够执行 Go 代码。<br>调度时会采用抢占式调度模型以避免一个 goroutine 运行太长时间；某个 P 的队列变空时会从其它的 P 队列上偷 G，然后继续运行。</p><p><a href="http://morsmachine.dk/go-scheduler" target="_blank" rel="noopener">http://morsmachine.dk/go-scheduler</a></p><p><img src="https://i6448038.github.io/img/csp/GMPrelation.png" alt></p><h3 id="系统调用细节"><a class="markdownIt-Anchor" href="#系统调用细节"></a> 系统调用细节</h3><p>当某个 goroutine 发起一次系统调用时，会调用 <code>runtime.entersyscall</code>。<br>调度器会将 G 的状态设置为 <code>Gsyscall</code> 后放入就绪队列；<br>此时，p 会和 m 进行剥离，p 的状态被设为 <code>Psyscall</code>，而 m 会去执行系统调用。<br>如果系统调用时非阻塞的，那么 m 会很快返回。返回时会调用 <code>runtime.exitsyscall</code>，这个时候会去检查当前 m 的 P，如果 P 处于 <code>Psyscall</code> 且队列非空，则重新将 p 和 m 绑定，恢复 g 的状态为 <code>Grunning</code>，继续运行。</p><p>如果 goroutine 发起的是阻塞的系统调用，则会调用 <code>runtime.entersyscallblock</code>。<br>与 <code>entersyscall</code> 不同的是，<code>entersyscallblock</code> 会调用 <code>releasep</code> 和 <code>handoffp</code>。<br><code>releasep</code> 将当前的 M 与 M 关联的 P 剥离，M 会负责去执行系统调用；<br>执行 <code>handoffp</code> 会让 P 尝试挂靠到其它空闲的 M 上继续执行。<br>如果 P 上没有 G 了，P 会被设置为 <code>Pidle</code>；如果没有空闲的 M 了，则会调用 <code>startm</code> 来让 P 与新的 M 绑定后继续执行。<br>当系统调用完成时，要让发起调用的 G 来继续执行。这时 G 会去找可用的 P。如果当前不存在 <code>Pidle</code> 的 P，调度器将会把 G 变成 <code>Grunnable</code>，将它挂到全局的就绪 G 队列中，然后停止当前 m 并调用 <code>schedule</code> 函数。<br><em>换句话说，block 的时候，可能 m 上的 P 会空闲，等 m 返回后还可以继续挂载执行，此时 M-P-G 的绑定原样恢复。整个逻辑就有点像非阻塞调用。如果 m 上的 P 去干别的了（比如又找了个新的 M 继续执行），那么当前 m 会将信息传递给 G，改变 G 的状态，然后 m 自己退出（因为所有的 P 都有 M 了）</em></p><h2 id="内存管理"><a class="markdownIt-Anchor" href="#内存管理"></a> 内存管理</h2><h3 id="内存池"><a class="markdownIt-Anchor" href="#内存池"></a> 内存池</h3><p>每个线程都会有自己的本地内存，当线程内存不够时会向全局分配链中申请内存。</p><p>Go 会为每个 M 在 <code>MCache</code> 中存储一些空闲的小内存块；作为备用分配存储。当 <code>MCache</code> 用完后，会从 <code>MCentral</code> 自由链拿<strong>一些</strong>对象进行补充；<code>MCentral</code> 为空时，又会从 <code>Mheap</code> 中拿一些对象进行补充。这样的多级批量补充机制减小了全局内存加锁的开销。</p><ul><li>当程序需要小对象（小于 32K）时，会直接从 <code>MCache</code> 中分配，对象被回收后控制内存返回给全局控制堆（<code>MHeap</code>）；<br>从 <code>MCache</code> 中分配避免了在全局控制堆上频繁加锁。</li><li>当需要大对象时，会直接从全局控制堆上以页（4KB）为单位进行分配。因此大对象总是页对齐的。</li></ul><h3 id="垃圾回收"><a class="markdownIt-Anchor" href="#垃圾回收"></a> 垃圾回收</h3><p>Go 语言使用标记清除算法来完成垃圾回收，整个回收过程会 stop the world.<br>标记阶段从 root 区域出发，扫描所有直接或间接引用的对象；清除阶段直接扫描堆区，对未被标记的对象进行回收。<br>由于标记过程是一个树形的操作，所以这个过程被并行化，以提升速度。</p><h2 id="网络"><a class="markdownIt-Anchor" href="#网络"></a> 网络</h2><p>Go 通过运行时层面对 epoll/kqueue 的封装来实现非阻塞 io.</p><p>封装层次：</p><ul><li>平台相关的 API 封装</li><li>平台独立的 runtime 封装</li><li>用户级别的库封装（如 <code>net</code>）</li></ul><p>在 <code>runtime.main</code> 启动时，会运行 <code>newm(sysmon, nil)</code>，而 sysmon 就会每隔一段时间执行 <code>runtime.epoll</code>。sysmon 的地位要比 gc 重要的多，而且会频繁执行，所以会单独为它分配一个系统线程（m）来运行。</p></div><div class="article-footer"><blockquote class="mt-2x"><ul class="post-copyright list-unstyled"><li class="post-copyright-link hidden-xs"><strong>本文链接：</strong> <a href="https://blog.stdioa.com/2019/06/go-internal-note/" title="《深入解析Go》笔记" target="_blank" rel="external">https://blog.stdioa.com/2019/06/go-internal-note/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！</li></ul></blockquote><div class="panel panel-default panel-badger"><div class="panel-body"><figure class="media"><div class="media-left"><a href="/" target="_blank" class="img-burn thumb-sm visible-lg"><img src="https://www.gravatar.com/avatar/e452ed622e6b1e9a2067a06fde30cf30?s=128" class="img-rounded w-full" alt=""></a></div><div class="media-body"><h3 class="media-heading"><a href="/" target="_blank"><span class="text-dark">David Dai</span><small class="ml-1x">Backend Developer</small></a></h3><div>小孩子。</div></div></figure></div></div></div></article><section id="comments"><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div></section></div><nav class="bar bar-footer clearfix" data-stick-bottom><div class="bar-inner"><ul class="pager pull-left"><li class="prev"><a href="/2020/09/using-beancount/" title="开始使用 Beancount"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a></li><li class="next"><a href="/2019/06/golang-learning-experience/" title="Golang 学习记录"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a></li><li class="toggle-toc"><a class="toggle-btn collapsed" data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="文章目录" role="button"><span>[&nbsp;</span><span>文章目录</span> <i class="text-collapsed icon icon-anchor"></i> <i class="text-in icon icon-close"></i> <span>]</span></a></li></ul><div class="bar-right"><div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,qzone"></div></div></div></nav></main><footer class="footer" itemscope itemtype="http://schema.org/WPFooter"><ul class="social-links"><li><a href="https://github.com/StdioA" target="_blank" title="Github" data-toggle="tooltip" data-placement="top"><i class="icon icon-github"></i></a></li><li><a href="https://twitter.com/stdio_a" target="_blank" title="Twitter" data-toggle="tooltip" data-placement="top"><i class="icon icon-twitter"></i></a></li><li><a href="/atom.xml" target="_blank" title="Rss" data-toggle="tooltip" data-placement="top"><i class="icon icon-rss"></i></a></li><li><a href="https://t.me/StdioA" target="_blank" title="Telegram" data-toggle="tooltip" data-placement="top"><i class="icon icon-telegram"></i></a></li></ul><div class="copyright"><div class="publishby">Theme by <a href="https://github.com/cofess" target="_blank">cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.</div></div></footer><script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script><script>window.jQuery||document.write('<script src="js/jquery.min.js"><\/script>')</script><script src="/js/plugin.min.js"></script><script src="/js/application.js"></script><script>window.INSIGHT_CONFIG={TRANSLATION:{POSTS:"文章",PAGES:"页面",CATEGORIES:"分类",TAGS:"标签",UNTITLED:"(未命名)"},ROOT_URL:"/",CONTENT_URL:"/content.json"}</script><script src="/js/insight.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script defer>var disqus_config=function(){this.page.url="https://blog.stdioa.com/2019/06/go-internal-note/",this.page.identifier="go-internal-note"};!function(){var t=document,e=t.createElement("script");e.src="//stdioa.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><script defer type="text/javascript">!function(e,a,t,n,g){e.GoogleAnalyticsObject="ga",e.ga=e.ga||function(){(e.ga.q=e.ga.q||[]).push(arguments)},e.ga.l=+new Date,n=a.createElement(t),g=a.getElementsByTagName(t)[0],n.async=1,n.src="//www.google-analytics.com/analytics.js",g.parentNode.insertBefore(n,g)}(window,document,"script"),ga("create","UA-65107715-1","auto"),ga("send","pageview")</script></body></html>